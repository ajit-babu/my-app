
name: CI/CD Pipeline with SonarQube

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  HARBOR_HOST: ${{ secrets.HARBOR_HOST }}
  HARBOR_PROJECT: library
  IMAGE_NAME: my-app
  SONAR_HOST: ${{ secrets.SONAR_HOST }}

jobs:
  code-quality:
    name: Code Quality Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Shallow clones should be disabled for better analysis
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run tests with coverage
      run: |
        pytest --cov=. --cov-report=xml --cov-report=term
    
    - name: SonarQube Scan
      uses: sonarsource/sonarqube-scan-action@master
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST }}
    
    - name: SonarQube Quality Gate Check
      uses: sonarsource/sonarqube-quality-gate-action@master
      timeout-minutes: 5
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST }}
      # Optional: Fail pipeline if quality gate fails
      continue-on-error: false

  build-and-push:
    name: Build and Push Docker Image
    needs: code-quality  # Only run if code quality passes
    runs-on: ubuntu-latest
    
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      full_image: ${{ steps.meta.outputs.full_image }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Generate image metadata
      id: meta
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
        FULL_IMAGE="${{ env.HARBOR_HOST }}/${{ env.HARBOR_PROJECT }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
        
        echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "full_image=${FULL_IMAGE}" >> $GITHUB_OUTPUT
        
        echo "ðŸ·ï¸ Image Tag: ${IMAGE_TAG}"
        echo "ðŸ“¦ Full Image: ${FULL_IMAGE}"
    
    - name: Login to Harbor
      uses: docker/login-action@v2
      with:
        registry: ${{ env.HARBOR_HOST }}
        username: ${{ secrets.HARBOR_USERNAME }}
        password: ${{ secrets.HARBOR_PASSWORD }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: |
          ${{ steps.meta.outputs.full_image }}
          ${{ env.HARBOR_HOST }}/${{ env.HARBOR_PROJECT }}/${{ env.IMAGE_NAME }}:latest
        build-args: |
          VERSION=${{ steps.meta.outputs.image_tag }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Image scan (Harbor/Trivy)
      run: |
        echo "Image built and pushed: ${{ steps.meta.outputs.full_image }}"
        echo "Harbor will automatically scan with Trivy"

  deploy:
    name: Deploy to Kubernetes
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config
        kubectl cluster-info
    
    - name: Create namespace if not exists
      run: |
        kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Create Harbor registry secret
      run: |
        kubectl create secret docker-registry harbor-registry-secret \
          --docker-server=${{ env.HARBOR_HOST }} \
          --docker-username=${{ secrets.HARBOR_USERNAME }} \
          --docker-password=${{ secrets.HARBOR_PASSWORD }} \
          --namespace=production \
          --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Update deployment manifest
      run: |
        IMAGE_TAG="${{ needs.build-and-push.outputs.image_tag }}"
        FULL_IMAGE="${{ needs.build-and-push.outputs.full_image }}"
        
        cat > deployment.yaml <<DEPLOY
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  namespace: production
  labels:
    app: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
        version: "${IMAGE_TAG}"
    spec:
      imagePullSecrets:
      - name: harbor-registry-secret
      containers:
      - name: app
        image: ${FULL_IMAGE}
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: VERSION
          value: "${IMAGE_TAG}"
        - name: ENV
          value: "production"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
  namespace: production
spec:
  type: NodePort
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30088
    name: http
DEPLOY
        
        cat deployment.yaml
    
    - name: Deploy to Kubernetes
      run: |
        kubectl apply -f deployment.yaml
        kubectl rollout status deployment/my-app -n production --timeout=5m
    
    - name: Verify deployment
      run: |
        echo "ðŸ“Š Deployment Status:"
        kubectl get deployments -n production
        echo ""
        echo "ðŸ“¦ Pods:"
        kubectl get pods -l app=my-app -n production
        echo ""
        echo "ðŸŒ Services:"
        kubectl get svc my-app-service -n production
    
    - name: Get application URL
      run: |
        echo "ðŸš€ Application deployed successfully!"
        echo "Access the application at: http://$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}'):30088"

  notify:
    name: Notification
    needs: [code-quality, build-and-push, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Send notification
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "âœ… Pipeline completed successfully!"
        else
          echo "âŒ Pipeline failed!"
        fi

